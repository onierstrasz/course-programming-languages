\begin{enumerate}
% 1. Distinguish the key characteristics of the functional and logic programming styles.
\item 
\begin{description}
\item [functional] working in the terms of mathematical function, the state of a variable cannot be modified
\item [logic] a program is decomposed into facts and rules, used to develop new facts, that is express thing that you know and rules for inferring new thing
\end{description}

% 2. How do you compute (1 + 3) * 2 in a stack-based language like PostScript? Note the contents of the stack after each operation.
\item
\texttt{1 \% 1\\
	3 \% 1 3\\
	add \% 4\\
	2 \% 4 2\\
	mul \% 8}


% 3. Why don't pure functional languages provide loop constructs?
\item Explicit loop constructs are intended to change the state of an entity (object, variable, etc.). But in a pure functional language there is no state because of referential transparency. So iterative processes are accomplished by means of recursion, thus function calls, which does not violate referential transparency.

% 4. What is the difference between monomorphic and polymorphic type? Is the following Haskell function monomorphic or polymorphic? Why?
\item ``Monomorphic'' means ``every value has a single, unique type''. ``Polymorphic'' means that a value can have more than one type. The function is polymorphic, since it accepts a list whose elements can be any type on which the \texttt{+} function can be applied.

% 5. Explain how it is possible to use the concept of recursion in the $\lambda$-calculus.
%\item We know by the Fixed-Point theorem that every $\lambda$-expression $e$ has a fixed point $p$, i.e. $(e ~p) \equiv p$. Thus recursive functions (i.e. recursive $\lambda$-expressions) can be expressed as fixed-points of other suitable expressions, which must be well-defined. Finding this fixed-point is achieved in the (untyped) lambda-calculus by means of a fixed-point combinator called the \emph{Y-combinator}. So if we define a function $p$ to be the Y-combinator applied to an expression $e$, the result of this application is the again the expression with the desired function as argument, $e~p$, which equals $p$.

% 5. Why is normal order evaluation called lazy?
\item Because expressions are only evaluated when they are needed, the evaluation is delayed.
\begin{verbatim}
    sqr (7-3) => (7-3) * (7-3) => 4 * (7-3) => 4 * 4 => 16
\end{verbatim}

% 6. What is the difference between syntax and semantics?
\item Syntax: the arrangement of words and phrases to create well-formed sentences in a language \\
Semantics: the meaning of a word, phrase, sentence or text\\
You can create well-formed sentences (according to the syntax) that don't have a meaning (according to semantics).

% 7. List differences between a class-based and a prototype-based programming language.
\item Class-based: works with classes, classes inherit from classes, objects cannot be extended easily, normally based on statically typed languages
Prototype-based: works with prototype objects, objects inherit from objects, objects can be extended easily, normally based on interpreted and dynamically typed languages, 

% 8. What happens in JavaScript if we assign a variable without using the command ``var''? What problem can it cause?
\item We override the variable in the closest scope in a scope chain. If no such variable exists, the global variable is created.

% 9. What does the closed world assumption in Prolog state?
\item Anything that cannot be inferred with given data is assumed false.

% 10. Is there a difference between logical negation \texttt{$\neg$} and \texttt{not} operator implemented using cut and fail? Explain.  \\
%\texttt{not(X) :- X!, fail. } \\
%\texttt{not(\_).}
%\item Yes, cut and fail $A \wedge \neg B = \neg B \wedge A$ but $A, not(B) \not = not(B), A$

\end{enumerate}

